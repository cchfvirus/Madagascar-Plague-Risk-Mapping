<!DOCTYPE html>
<html>
<head>
    <title>Plague Risk Mapping - Interactive Layers</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        
        .info { 
            padding: 10px 12px; 
            background: white; 
            box-shadow: 0 0 15px rgba(0,0,0,0.2); 
            border-radius: 5px; 
            max-width: 300px;
        }
        
        .info h4 { margin: 0 0 5px; color: #333; }
        .info p { margin: 5px 0; font-size: 12px; color: #666; }
        
        .legend {
            line-height: 20px;
            color: #555;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            max-width: 200px;
        }
        
        .legend h4 { margin: 0 0 8px; font-size: 14px; }
        
        .legend i {
            width: 20px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.8;
            border: 1px solid #ccc;
        }
        
        .legend .item { 
            margin-bottom: 5px; 
            overflow: hidden; 
            font-size: 11px;
        }
        
        .legend .gradient-bar {
            width: 100%;
            height: 20px;
            margin: 10px 0;
            border: 1px solid #ccc;
        }
        
        .legend .gradient-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            margin-top: 3px;
        }
        
        .layer-control {
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
        }
        
        .layer-control h4 { margin: 0 0 10px; }
        
        .layer-control label {
            display: block;
            margin: 8px 0;
            cursor: pointer;
            font-size: 14px;
        }
        
        .layer-control input[type="radio"] {
            margin-right: 8px;
        }
        
        .layer-control input[type="checkbox"] {
            margin-right: 8px;
        }
        
        .layer-control .overlay-section {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        
        .layer-control .overlay-section h5 {
            margin: 0 0 8px;
            font-size: 13px;
            font-weight: bold;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            z-index: 1000;
            text-align: center;
        }
        
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            font-size: 12px;
        }
        
        /* Popup styling */
        .leaflet-popup-content {
            margin: 10px;
            font-size: 12px;
        }
        
        .leaflet-popup-content h3 {
            margin: 0 0 8px;
            font-size: 14px;
            color: #333;
        }
        
        .leaflet-popup-content table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .leaflet-popup-content table td {
            padding: 3px 5px;
            border-bottom: 1px solid #eee;
        }
        
        .leaflet-popup-content table td:first-child {
            font-weight: bold;
            color: #666;
            width: 40%;
        }
        
        /* Coordinate copy notification */
        .copy-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .copy-notification.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div>Loading map layers...</div>
        <div id="load-status" style="margin-top: 10px; font-size: 12px;"></div>
    </div>
    <div id="map"></div>
    <div id="copy-notification" class="copy-notification"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/georaster@1.6.0/dist/georaster.browser.bundle.min.js"></script>
    <script src="https://unpkg.com/georaster-layer-for-leaflet@3.10.0/dist/georaster-layer-for-leaflet.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>

    <script>
        // Initialize map
        var map = L.map('map').setView([-18.8792, 47.5079], 6); // Madagascar center

        // Create custom panes with specific z-index ordering
        map.createPane('backgroundPane');
        map.getPane('backgroundPane').style.zIndex = 250; // Below raster layers
        
        map.createPane('rasterPane');
        map.getPane('rasterPane').style.zIndex = 300; // Above background, below overlays
        
        map.createPane('boundariesPane');
        map.getPane('boundariesPane').style.zIndex = 350; // Above rasters, below overlays (plague cases)

        // Add OpenStreetMap basemap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);

        // Store layers
        var layers = {};
        var currentLayer = null;
        var loadedCount = 0;
        var totalLayers = 3;
        var plagueCasesLayer = null;
        var madagascarBackgroundLayer = null;
        var highRiskBoundariesLayer = null;

        // Layer configurations
        var layerConfigs = {
            'enm': {
                file: 'enm_cog.tif',
                name: 'Ecological Niche Model (1km)',
                colors: ['#808080', '#ffed6f', '#ffc100', '#ff8c00', '#ff4500', '#dc143c', '#8b0000'],
                domain: [0, 1],
                labels: ['Low Suitability', 'High Suitability'],
                description: '',
                mode: 'lch',
                continuousLegend: true,
                blackBackground: false,
                useBackgroundPolygon: false
            },
            'risk': {
                file: 'risk_zones_cog.tif',
                name: 'Risk Zones (100m)',
                colors: ['#000000', '#FFFFBE', '#FFAA00', '#FF0000', '#A80000'],
                domain: [0, 4],
                labels: ['Low Risk', 'High Risk'],
                description: 'Plague Transmission Risk Zones',
                continuousLegend: true,
                blackBackground: false,
                useBackgroundPolygon: false
            },
            'hotspot': {
                file: 'hotspot_cog.tif',
                name: 'Hot Spot Analysis (100m)',
                colors: ['#0571b0', '#92c5de', '#000000', '#f4a582', '#ca0020'],
                domain: [-3, 3],
                labels: ['Cold Spot', 'Not Significant', 'Hot Spot'],
                description: 'Getis-Ord Gi* statistic showing spatial clustering of plague risk',
                customLegend: true,
                blackBackground: false,
                useBackgroundPolygon: true,
                legendItems: [
                    { value: 2.58, color: '#ca0020', label: 'Hot Spot with 99% Confidence' },
                    { value: 1.96, color: '#f4a582', label: 'Hot Spot with 95% Confidence' },
                    { value: 1.65, color: '#fddbc7', label: 'Hot Spot with 90% Confidence' },
                    { value: 0, color: '#000000', label: 'Not Significant' },
                    { value: -1.65, color: '#d1e5f0', label: 'Cold Spot with 90% Confidence' },
                    { value: -1.96, color: '#92c5de', label: 'Cold Spot with 95% Confidence' },
                    { value: -2.58, color: '#0571b0', label: 'Cold Spot with 99% Confidence' }
                ]
            }
        };

        // Function to copy coordinates to clipboard
        function copyCoordinatesToClipboard(lat, lng) {
            var coordText = lat.toFixed(6) + ', ' + lng.toFixed(6);
            
            // Try to use the modern clipboard API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(coordText).then(function() {
                    showCopyNotification('Coordinates copied: ' + coordText);
                }).catch(function(err) {
                    // Fallback method
                    fallbackCopyTextToClipboard(coordText);
                });
            } else {
                // Fallback for older browsers
                fallbackCopyTextToClipboard(coordText);
            }
        }

        // Fallback copy method for older browsers
        function fallbackCopyTextToClipboard(text) {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.top = "-9999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                var successful = document.execCommand('copy');
                if (successful) {
                    showCopyNotification('Coordinates copied: ' + text);
                } else {
                    showCopyNotification('Failed to copy coordinates', true);
                }
            } catch (err) {
                showCopyNotification('Failed to copy coordinates', true);
            }
            
            document.body.removeChild(textArea);
        }

        // Show notification when coordinates are copied
        function showCopyNotification(message, isError) {
            var notification = document.getElementById('copy-notification');
            notification.textContent = message;
            notification.style.background = isError ? 'rgba(198, 40, 40, 0.9)' : 'rgba(0, 0, 0, 0.8)';
            notification.classList.add('show');
            
            setTimeout(function() {
                notification.classList.remove('show');
            }, 2000);
        }

        // Load Madagascar boundary as background polygon
        function loadMadagascarBackground() {
            fetch('madagascar_boundary.geojson')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Madagascar boundary file not found');
                    }
                    return response.json();
                })
                .then(data => {
                    updateStatus('Loaded Madagascar boundary');
                    
                    madagascarBackgroundLayer = L.geoJSON(data, {
                        style: {
                            fillColor: '#000000',
                            fillOpacity: 0.4,
                            color: '#333333',
                            weight: 1,
                            opacity: 0.5
                        },
                        pane: 'backgroundPane' // Use custom pane with lower z-index
                    });
                    
                    // Don't add to map yet - only show when hotspot layer is active
                })
                .catch(error => {
                    console.error('Error loading Madagascar boundary:', error);
                    updateStatus('Note: Madagascar background not available', false);
                });
        }

        // Update loading status
        function updateStatus(message, isError) {
            var statusDiv = document.getElementById('load-status');
            if (isError) {
                statusDiv.innerHTML += '<div class="error">' + message + '</div>';
            } else {
                statusDiv.innerHTML += '<div>' + message + '</div>';
            }
            console.log(message);
        }

        // Load plague cases from GeoJSON
        function loadPlagueCases() {
            fetch('cases.geojson')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Plague cases file not found');
                    }
                    return response.json();
                })
                .then(data => {
                    updateStatus('Loaded ' + data.features.length + ' plague cases');
                    
                    plagueCasesLayer = L.geoJSON(data, {
                        pointToLayer: function(feature, latlng) {
                            return L.circleMarker(latlng, {
                                radius: 6,
                                fillColor: '#fff',
                                color: '#000000',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 1
                            });
                        },
                        onEachFeature: function(feature, layer) {
                            // Create popup content with all attributes
                            var popupContent = '<h3>Plague Case</h3><table>';
                            
                            // Loop through all properties
                            for (var key in feature.properties) {
                                if (feature.properties.hasOwnProperty(key)) {
                                    var value = feature.properties[key];
                                    // Format the key to be more readable
                                    var displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, function(l){ return l.toUpperCase() });
                                    popupContent += '<tr><td>' + displayKey + '</td><td>' + value + '</td></tr>';
                                }
                            }
                            
                            popupContent += '</table>';
                            
                            layer.bindPopup(popupContent, {
                                maxWidth: 300,
                                maxHeight: 400
                            });
                        }
                    });
                    
                    // Add to map by default
                    plagueCasesLayer.addTo(map);
                })
                .catch(error => {
                    console.error('Error loading plague cases:', error);
                    updateStatus('Note: Plague cases layer not available', false);
                });
        }

        // Toggle plague cases layer
        function togglePlagueCases(show) {
            if (plagueCasesLayer) {
                if (show) {
                    plagueCasesLayer.addTo(map);
                } else {
                    map.removeLayer(plagueCasesLayer);
                }
            }
        }

        // Load high risk boundaries
        function loadHighRiskBoundaries() {
            fetch('high_risk_boundaries.geojson')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('High risk boundaries file not found');
                    }
                    return response.json();
                })
                .then(data => {
                    updateStatus('Loaded high risk boundaries');
                    
                    highRiskBoundariesLayer = L.geoJSON(data, {
                        style: {
                            fillColor: '#000000',
                            fillOpacity: 0.5,
                            color: '#FFFFFF',
                            weight: 2,
                            opacity: 1
                        },
                        interactive: false,  // Make non-clickable
                        pane: 'boundariesPane'  // Use custom pane below overlays
                    });
                    
                    highRiskBoundariesLayer.addTo(map);
                })
                .catch(error => {
                    console.error('Error loading high risk boundaries:', error);
                    updateStatus('Note: High risk boundaries layer not available', false);
                });
        }

        // Toggle high risk boundaries layer
        function toggleHighRiskBoundaries(show) {
            if (highRiskBoundariesLayer) {
                if (show) {
                    highRiskBoundariesLayer.addTo(map);
                } else {
                    map.removeLayer(highRiskBoundariesLayer);
                }
            }
        }

        // Load a layer
        function loadLayer(layerId) {
            var config = layerConfigs[layerId];
            
            updateStatus('Loading ' + config.name + '...');
            
            fetch(config.file)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP error! status: ' + response.status);
                    }
                    updateStatus(config.name + ' fetched successfully');
                    return response.arrayBuffer();
                })
                .then(arrayBuffer => {
                    updateStatus('Parsing ' + config.name + '...');
                    return parseGeoraster(arrayBuffer);
                })
                .then(georaster => {
                    updateStatus(config.name + ' parsed successfully');
                    
                    // Create color scale with optional mode parameter for smoother gradients
                    var scale = config.mode 
                        ? chroma.scale(config.colors).mode(config.mode).domain(config.domain)
                        : chroma.scale(config.colors).domain(config.domain);
                    
                    var layer = new GeoRasterLayer({
                        georaster: georaster,
                        opacity: 0.75,
                        pixelValuesToColorFn: function(values) {
                            var value = values[0];
        
                        // Handle null/undefined/NaN values
                        if (value === null || value === undefined || isNaN(value)) {
                            return null;
                        }
        
                        // For risk zones, filter out values outside valid range (0-4)
                        if (layerId === 'risk' && (value < 0 || value > 4)) {
                            return null;
                        }
        
                        return scale(value).hex();
                    },
                    resolution: 256,
                    pane: 'rasterPane'
                });
                    
                    layers[layerId] = layer;
                    loadedCount++;
                    
                    updateStatus(config.name + ' ready! (' + loadedCount + '/' + totalLayers + ')');
                    
                    // If this is the first layer loaded, show it and fit bounds
                    if (!currentLayer) {
                        // Add background polygon if this layer needs it
                        if (config.useBackgroundPolygon && madagascarBackgroundLayer) {
                            madagascarBackgroundLayer.addTo(map);
                        }
                        
                        // Then add the raster layer
                        layer.addTo(map);
                        currentLayer = layerId;
                        map.fitBounds(layer.getBounds());
                        updateLegend(layerId);
                    }
                    
                    // Hide loading screen when all layers are loaded
                    if (loadedCount === totalLayers) {
                        setTimeout(function() {
                            document.getElementById('loading').style.display = 'none';
                        }, 1000);
                    }
                })
                .catch(error => {
                    var errorMsg = 'Error loading ' + config.name + ': ' + error.message;
                    updateStatus(errorMsg, true);
                    console.error(errorMsg, error);
                    
                    // Show specific CORS error message
                    if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                        updateStatus('⚠️ CORS Error: You must serve files through a web server!', true);
                        updateStatus('Try using: R servr::httd() or Python http.server', true);
                    }
                });
        }

        // Switch between layers
        function switchLayer(layerId) {
            if (currentLayer && layers[currentLayer]) {
                map.removeLayer(layers[currentLayer]);
            }
            
            // Remove background polygon if it exists
            if (madagascarBackgroundLayer && map.hasLayer(madagascarBackgroundLayer)) {
                map.removeLayer(madagascarBackgroundLayer);
            }
            
            if (layers[layerId]) {
                var config = layerConfigs[layerId];
                
                // Add background polygon if this layer needs it
                if (config.useBackgroundPolygon && madagascarBackgroundLayer) {
                    madagascarBackgroundLayer.addTo(map);
                }
                
                // Then add the raster layer
                layers[layerId].addTo(map);
                currentLayer = layerId;
                updateLegend(layerId);
            }
        }

        // Update legend
        function updateLegend(layerId) {
            var config = layerConfigs[layerId];
            var legendDiv = document.getElementById('legend-content');
            
            legendDiv.innerHTML = '<h4>' + config.name + '</h4>';
            
            // Check if this layer has a custom legend
            if (config.customLegend && config.legendItems) {
                // Use custom legend items
                config.legendItems.forEach(function(item) {
                    legendDiv.innerHTML +=
                        '<div class="item"><i style="background:' + item.color + '"></i> ' +
                        item.label + '</div>';
                });
            } else if (config.continuousLegend) {
                // Create horizontal continuous gradient legend
                var gradientStops = [];
                for (var i = 0; i < config.colors.length; i++) {
                    var percentage = (i / (config.colors.length - 1)) * 100;
                    gradientStops.push(config.colors[i] + ' ' + percentage + '%');
                }
                var gradientCSS = 'linear-gradient(to right, ' + gradientStops.join(', ') + ')';
                
                legendDiv.innerHTML += 
                    '<div class="gradient-bar" style="background: ' + gradientCSS + ';"></div>' +
                    '<div class="gradient-labels">' +
                    '<span>' + config.labels[0] + '</span>' +
                    '<span>' + config.labels[1] + '</span>' +
                    '</div>';
            } else {
                // Use automatic discrete legend generation
                var numGrades = 5;
                var range = config.domain[1] - config.domain[0];
                var step = range / numGrades;
                
                // Create color scale with optional mode parameter
                var scale = config.mode 
                    ? chroma.scale(config.colors).mode(config.mode).domain(config.domain)
                    : chroma.scale(config.colors).domain(config.domain);
                
                for (var i = 0; i < numGrades; i++) {
                    var value = config.domain[0] + (step * i);
                    var nextValue = value + step;
                    var color = scale(value + step/2).hex();
                    
                    legendDiv.innerHTML +=
                        '<div class="item"><i style="background:' + color + '"></i> ' +
                        value.toFixed(2) + ' – ' + nextValue.toFixed(2) + '</div>';
                }
            }
            
            // Only add description if it's not empty
            if (config.description) {
                legendDiv.innerHTML += '<p style="margin-top:10px; font-size:11px; color:#777;">' + 
                                       config.description + '</p>';
            }
        }

        // Create layer control
        var layerControl = L.control({position: 'topleft'});
        layerControl.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'layer-control');
            div.innerHTML = '<h4>Base Layers</h4>';
            
            Object.keys(layerConfigs).forEach(function(key, index) {
                var checked = index === 0 ? 'checked' : '';
                div.innerHTML += 
                    '<label><input type="radio" name="layer" value="' + key + '" ' + checked + 
                    ' onchange="switchLayer(\'' + key + '\')">' + 
                    layerConfigs[key].name + '</label>';
            });
            
            // Add overlay section
            div.innerHTML += '<div class="overlay-section">';
            div.innerHTML += '<h5>Overlays</h5>';
            div.innerHTML += '<label><input type="checkbox" id="plague-cases-toggle" checked onchange="togglePlagueCases(this.checked)">Plague Cases</label>';
            div.innerHTML += '<label><input type="checkbox" id="high-risk-toggle" checked onchange="toggleHighRiskBoundaries(this.checked)">High Risk Boundaries</label>';
            div.innerHTML += '</div>';
            
            return div;
        };
        layerControl.addTo(map);

        // Create legend
        var legend = L.control({position: 'bottomright'});
        legend.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'legend');
            div.id = 'legend-content';
            return div;
        };
        legend.addTo(map);

        // Create info box
        var info = L.control({position: 'topright'});
        info.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info');
            div.innerHTML = 
                '<h4>Plague Risk Mapping - Madagascar</h4>' +
                '<p>Select a layer to view different risk assessments.</p> ' +
                '<p><em>Click plague case markers for details</em></p>' +
                '<p><em>Right-click map to copy coordinates</em></p>';
            return div;
        };
        info.addTo(map);

        // Add right-click handler to copy coordinates
        map.on('contextmenu', function(e) {
            copyCoordinatesToClipboard(e.latlng.lat, e.latlng.lng);
        });

        // Add click handler to show values
        map.on('click', function(e) {
            if (currentLayer && layers[currentLayer]) {
                console.log('Clicked at:', e.latlng);
            }
        });

        // Load all layers
        updateStatus('Starting to load layers...');
        Object.keys(layerConfigs).forEach(function(key) {
            loadLayer(key);
        });
        
        // Load plague cases
        loadPlagueCases();
        
        // Load Madagascar background
        loadMadagascarBackground();
        
        // Load high risk boundaries
        loadHighRiskBoundaries();
    </script>
</body>
</html>
